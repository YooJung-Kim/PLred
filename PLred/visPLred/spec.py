import numpy as np
import peakutils
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
from scipy.interpolate import griddata, interp1d
from PLred.imageutils import find_3point_peak, find_9point_peak_2d, iter_find_blob, apply_patch, find_centroid

# need to store this information somewhere else, maybe in the config file
# model_savedir = '/home/first/yjkim/visPL_tests/conf/models/'

def shift_image_warpaffine(im, shift_x, shift_y):
    ''' shift image using warpAffine '''
    import cv2
    # shift the image
    M = np.float32([[1,0,shift_x], [0,1,shift_y]])
    shifted = cv2.warpAffine(im, M, (im.shape[1], im.shape[0]))

    return shifted

def shift_image_fourier(im0, shift_x, shift_y, oversample_factor = 2, npad = 10):
    ''' shift image using Fourier transform '''

    from scipy.fft import fft2, ifft2, fftshift
    from scipy.ndimage import zoom

    im = zoom(im0, oversample_factor)
    padded = np.pad(im, npad)

    ny, nx = padded.shape
    ky = np.fft.fftfreq(ny)
    kx = np.fft.fftfreq(nx)
    ky, kx = np.meshgrid(ky, kx)

    fftim = fft2(padded)
    phase_shift = np.exp(-2j*np.pi*(shift_y*ky + shift_x*kx))
    shifted_fft = fftim * phase_shift
    shifted_image = np.real(ifft2(shifted_fft))

    return (zoom(shifted_image[npad:-npad, npad:-npad], 1/oversample_factor))


def shift_spectrum(spectrum, shift):
    # Fourier transform
    spectrum_fft = np.fft.fft(spectrum)
    N = len(spectrum)
    # Create phase shift
    k = np.fft.fftfreq(N) * 2 * np.pi * shift
    phase_shift = np.exp(-1j * k)
    # Apply phase shift
    shifted_spectrum_fft = spectrum_fft * phase_shift
    # Inverse Fourier transform to get the shifted spectrum
    shifted_spectrum = np.fft.ifft(shifted_spectrum_fft).real
    return shifted_spectrum

def flatten_im(im, xmin, xmax):
    ''' flatten image '''
    return im[:,xmin:xmax].flatten()

def vec_to_mat(vec, nspec = 38):
    ''' convert flattened spectrum to matrix '''
    return vec.reshape((nspec, -1))

def extract_spec_box(traces, image, boxsize = 3):
    ''' 
    extract spectra using box extraction 
    
    Parameters
    ----------
    traces : np.ndarray
        Traces for box extraction 
    image : np.ndarray
        Image to extract spectra from
    xmin : int
        Minimum x coordinate for spectral extraction
    xmax : int
        Maximum x coordinate for spectral extraction
    boxsize : int
        Box size for spectral extraction

    '''

    spec = np.zeros((len(traces), np.shape(image)[1]))

    for fibind in range(len(traces)):

        for x in np.arange(np.shape(image)[1]):

            loc = np.round(traces[fibind,x]).astype(int)
            spec[fibind, x] = np.sum(image[loc-boxsize:loc+boxsize, x])

    return spec


def extract_spec_optimal(A, imvec, imvar = None, badpix = None, var_const = 200, thresh = 1e-1):
    """
    Extract spectra from detector image using regularized spectral extraction.
    adapted from Mike's codes

    Parameters
    ----------  
    A : scipy.sparse.csrmatrix
        Sparse matrix for spectral extraction
    imvec : np.ndarray
        Image vector (flattened image)
    imvar : np.ndarray (optional)
        Variance image (flattened)
    badpix : np.ndarray (optional)
        Bad pixel mask
    var_const : float (optional)
        Variance constant
        Used if variance image is not given
    thresh : float (optional)
        Threshold for damping

    Returns
    -------
    np.ndarray
        Extracted spectra
    np.ndarray
        Reconstructed image
    """

    from scipy.sparse import diags
    from scipy.sparse.linalg import lsmr

    if imvar is None:
        w = np.ones(len(imvec)) / var_const
    else:
        w = 1. / imvar

    if badpix is not None:
        w[badpix] = 0

    W = diags(w, 0)
    ATW = A @ W
    ATWA = ATW.dot(A.T)
    ATWx = ATW.dot(imvec)
    ATWAdiag = ATWA.diagonal()

    damp = thresh * ATWAdiag.max()
    spec_lw, istop, itn, normr, normar, norma, conda, normx = \
        lsmr(ATWA, ATWx,
            damp=damp,
            )
    
    recon = spec_lw @ A
    return spec_lw, recon   


def interpolate_spectrum(spectrum, wavmap, ref_ind = 0):
    '''
    Interpolate spectrum to the reference wavelength map

    Parameters
    ----------
    spectrum : np.ndarray (NFIB x NWAV)
        Spectrum to be interpolated
    wavmap : np.ndarray
        Wavelength map (generated by build_wavelength_solutions() in SpectrumModel)
    ref_ind : int
        Reference index for the wavelength map

    Returns
    -------
    np.ndarray
        Interpolated spectrum
    '''

    from scipy.interpolate import interp1d

    interp_spectrum = []
    for fibind in range(len(spectrum)):
        interp = interp1d(wavmap[fibind], spectrum[fibind], fill_value='extrapolate', kind = 'cubic')
        interp_spectrum.append(interp(wavmap[ref_ind]))

    interp_spectrum = np.array(interp_spectrum)

    return interp_spectrum


def find_multiple_peaks(array, n_peaks = 38, min_dist = 6):
    '''
    Find multiple peaks by finding maximum peaks and masking the region around the peak

    Parameters
    ----------
    array : np.ndarray
        1D array to find peaks
    n_peaks : int
        Number of peaks to find
    min_dist : int
        Minimum distance between peaks

    Returns
    -------
    np.ndarray
        Indices of the peaks
    '''

    _array = array.copy()

    locs = np.zeros(n_peaks, dtype=int)

    for i in range(n_peaks):
        _loc = np.argmax(_array)
        locs[i] = _loc
        _array[_loc - min_dist//2 : _loc + min_dist//2] = 0
    
    return locs

def frame_to_spec(frame, xmin, xmax, wavmap = None, 
                #   optimal_extraction = True,
                  matrix = None, traces = None,
                  imvar = None, badpix = None, var_const = 200, thresh = 1e-1, 
                  boxsize = 3,
                  ref_ind = 0,
                  return_residual = False):
    '''
    Extract spectrum from a frame using the matrix

    Parameters
    ----------
    frame : np.ndarray
        Frame to extract spectrum from
    xmin : int
        Minimum x coordinate for spectral extraction
    xmax : int
        Maximum x coordinate for spectral extraction
    wavmap : np.ndarray
        Wavelength map (generated by build_wavelength_solutions() in SpectrumModel)
    matrix : np.ndarray (optional)
        Matrix for optima spectral extraction. If not given, box extraction is used.
    traces : np.ndarray (optional)
        Traces for box extraction. needs to be already truncated to xmin:xmax
    imvar : np.ndarray (optional)
        Variance image (flattened)
    badpix : np.ndarray (optional)
        Bad pixel mask
    var_const : float (optional)
        Variance constant
        Used if variance image is not given
    thresh : float (optional)
        Threshold for damping
    ref_ind : int
        Reference index for the wavelength map
    return_residual : bool
        Return residual image

    Returns
    -------
    np.ndarray
        Extracted and wavelength interpolated spectrum
    np.ndarray
        Residual image (if return_residual is True)
    '''

    if matrix is not None:
        # do optimal extraction
        imvec = flatten_im(frame, xmin, xmax)
        if imvar is not None: imvar_vec = flatten_im(imvar, xmin, xmax)
        else: imvar_vec = None
        spec, recon = extract_spec_optimal(matrix, imvec, imvar = imvar_vec, badpix = badpix, var_const = var_const, thresh = thresh)
        spec = vec_to_mat(spec)
    else:
        # do box extraction
        assert traces is not None, "traces should be given for box extraction. otherwise, use matrix for optimal extraction"
        assert return_residual is False, "return_residual is not supported for box extraction"
        spec = extract_spec_box(traces, frame[:,xmin:xmax], boxsize = boxsize)

    if wavmap is not None:
        # interpolate to the reference wavelength
        interpolated_spec = interpolate_spectrum(spec, wavmap, ref_ind = ref_ind)
    else:
        interpolated_spec = spec

    if return_residual:
        return interpolated_spec, (imvec - recon).reshape((-1, xmax-xmin))
    else:
        return interpolated_spec
    

class SpectrumModel:

    # number of traces
    NFIB = 38

    # image parameters
    NY, NX = 412, 1896 # pix
    XG, YG = np.meshgrid(range(NX), range(NY))
    CANVAS = np.zeros((NY, NX))

    # Neon emission line wavelengths
    WAVS = [748.9, 724.5, 703.2, 693, 671.7, 667.8, 659.9, 653.3, 650.7, 640.2, 638.2, 633.4, 626.7]
    NWAV = len(WAVS)

    # Initial estimate of the x positions of the neon lines
    INI_X_NEON = [ 279,  535,  746,  847, 1056, 1094, 1172, 1237, 1262, 1364, 1383, 1431, 1497]

    # Spectral extraction range
    XMIN = 200 # pix
    XMAX = 1500 # pix
    XARR = np.arange(XMIN, XMAX)

    YARR = np.arange(0, NY)

    # display params
    NEON_VMAX = 300
    FLAT_VMAX = 100
    
    model = None
    neon = None
    flat = None

    VERTICAL_TRACE = False

    def __init__(self, modelname, neonfile = None, flatfile = None):

        '''
        Build visible PL spectrum model using Neon and Flat data.
        Neon data is used for wavelength calibration and flat data is used to trace spectra.
        
        Workflow:
        1) find_peaks() to find the initial positions of the neon lines
        2) trace_spectra() to trace the spectra
        3) make_clean_LSF_models() to detect Neon lines and make LSF models
        - (optional) make_synthetic_LSFs() to check if the LSF models are correct
        4) construct_matrix() to build the matrix for spectral extraction
        - (optional) use iter_construct_matrix() to iteratively build the matrix, correcting for offsets
        5) build_wavelength_solutions() to build wavelength solutions
        6) save_spectra_model() to save the model
        '''

        # if modelfile is not None:
            
        #     self.model = self.load_model(modelfile)
        #     print('Spectrum Model file %s loaded' % modelfile)
        
        if neonfile is not None:

            self.neon = np.load(neonfile)
            print('Neon file %s loaded' % neonfile)
        
        if flatfile is not None:

            self.flat = np.load(flatfile)
            print('Flat file %s loaded' % flatfile)

        
        os.makedirs(modelname, exist_ok = True)
        print("model will be saved in", modelname)
        self.modelname = modelname

    def find_peaks(self, window = 6, min_dist = 5, use_peakutils = True, thres = 0.05, plot = True):
        '''
        Find rough line spread function coordinates using Neon image.
        Results are stored in self.ini_xs and self.ini_ys

        Parameters
        ----------
        window : int
            Window size for peak finding (number of x pixels to sum)
        min_dist : int
            Minimum distance between peaks
        use_peakutils : bool
            Use peakutils for peak finding
        thres : float
            Threshold for peakutils
        plot : bool
            Plot the result

        '''

        assert self.neon is not None, "Neon image should be stored in self.neon first"

        self.ini_ys = np.zeros((self.NFIB, self.NWAV)).astype(int)
        self.ini_xs = np.array([self.INI_X_NEON] * self.NFIB).astype(int)

        # find peaks going through each wavelength
        for i in range(self.NWAV):

            sliced_im = self.neon[:,self.INI_X_NEON[i] - window: self.INI_X_NEON[i] + window]

            if use_peakutils:
                inds = peakutils.indexes(np.sum(sliced_im, axis=1), thres = thres, min_dist = min_dist)
            else:
                inds = find_multiple_peaks(np.sum(sliced_im, axis=1), n_peaks = self.NFIB, min_dist = min_dist)

            assert len(inds) == self.NFIB, "For wavelength ind %d, the number of detected peaks is %d instead of %d. adjust params." % (i, len(inds), self.NFIB)

            self.ini_ys[:,i] = inds

        if plot:

            plt.imshow(self.neon, cmap='turbo', vmin=0, vmax=self.NEON_VMAX)
            for (x, y) in zip(self.ini_xs.flatten(), self.ini_ys.flatten()):
                plt.plot(x, y, 'x', color='red')
            plt.title('Initial Neon line positions')

    # def load_trace(self, tracefile):

    #     trace_coeffs = np.load(tracefile)

    #     self.trace_funcs = []
    #     self.trace_vals = []
    #     self.trace_poly_coeffs = []

    #     for fibind in range(self.NFIB):
    #         opt = trace_coeffs[fibind] 
    #         fun = np.poly1d(opt)
            
    #         self.trace_funcs.append(fun)
    #         self.trace_vals.append(fun(self.XARR))
    #         self.trace_poly_coeffs.append(opt)


    def trace_spectra(self, ini_wav_ind, trace_width = 4, poly_deg = 5, verbose = False,
                      save = False):

        trace_out = np.zeros((self.NFIB, self.XMAX - self.XMIN))

        for fibind in tqdm(range(self.NFIB)):

            # leftward

            xint = np.round(self.ini_xs[fibind,ini_wav_ind]).astype(int)
            yint = np.round(self.ini_ys[fibind,ini_wav_ind]).astype(int)

            for x in np.arange(xint, self.XMIN - 1, -1):

                prev_y = yint

                crop = self.flat[yint - trace_width : yint + trace_width, x]
                # plt.plot(np.arange(yint - trace_width, yint + trace_width), crop)
                try:
                    peak = find_3point_peak(np.arange(yint - trace_width, yint + trace_width), crop)
                    # print(x, self.XMIN)
                    trace_out[fibind, x - self.XMIN] = peak

                    # proposed new integer y location
                    new_yint = np.round(peak).astype(int)

                    if np.abs(prev_y - new_yint) == 1:
                        # accept the change
                        yint = new_yint
                    
                    elif np.abs(prev_y - new_yint) > 1:
                        # do not accept sudden jump
                        if verbose: print("abrupt peak jump detected for fib %d and x %d" % (fibind, x))
                        yint = prev_y
                        trace_out[fibind, x - self.XMIN] = np.nan

                except:
                    if verbose: print("peak finding failed for fib %d and x %d" % (fibind, x))
                    trace_out[fibind, x - self.XMIN] = np.nan
            

            # rightward

            xint = np.round(self.ini_xs[fibind,ini_wav_ind]).astype(int)
            yint = np.round(self.ini_ys[fibind,ini_wav_ind]).astype(int)

            for x in np.arange(xint, self.XMAX, 1):

                prev_y = yint

                crop = self.flat[yint - trace_width : yint + trace_width, x]

                try:
                    peak = find_3point_peak(np.arange(yint - trace_width, yint + trace_width), crop)

                    trace_out[fibind, x - self.XMIN] = peak

                    # proposed new integer y location
                    new_yint = np.round(peak).astype(int)

                    if np.abs(prev_y - new_yint) == 1:
                        # accept the change
                        yint = new_yint
                    
                    elif np.abs(prev_y - new_yint) > 1:
                        # do not accept sudden jump
                        if verbose: print("abrupt peak jump detected for fib %d and x %d" % (fibind, x))
                        yint = prev_y
                        trace_out[fibind, x - self.XMIN] = np.nan

                except:
                    if verbose: print("peak finding failed for fib %d and x %d" % (fibind, x))
                    trace_out[fibind, x - self.XMIN] = np.nan
        
        
        plt.imshow(self.flat, vmin=0, vmax=self.FLAT_VMAX)
        
        # build interpolation model

        self.trace_funcs = []
        self.trace_vals = []
        self.trace_poly_coeffs = []

        for fibind in range(self.NFIB):

            idx = np.isfinite(trace_out[fibind])
            opt = np.polyfit(self.XARR[idx], trace_out[fibind][idx], deg = poly_deg)
            fun = np.poly1d(opt)
            plt.plot(self.XARR, fun(self.XARR))

            self.trace_funcs.append(fun)
            self.trace_vals.append(fun(self.XARR))
            self.trace_poly_coeffs.append(opt)

        plt.title('Spectrum tracing result')

        self.raw_trace = trace_out

        if save:
            np.save(self.modelname+'/trace.npy', self.trace_poly_coeffs)
            print(self.modelname+'/trace.npy saved')


    def plot_traces(self):

        for fibind in range(self.NFIB):
            plt.plot(self.XARR, self.trace_funcs[fibind](self.XARR), color='white', alpha=0.3)
        
        if self.VERTICAL_TRACE:
            for f in self.vertical_trace_funcs:
                plt.plot(f(self.YARR), self.YARR, color='yellow', alpha=0.3)

    ### TODO: make trace along another direction as well, so that I don't have to measure centroids and center the postages
    ### turns out that there's weird zig-zag pattern. something related to polarization?

    def fit_vertical_traces(self, wavinds, poly_deg = 3):

        self.vertical_trace_funcs = []

        for wavind in wavinds:
            opt = np.polyfit(self.lsf_ycoors[:,wavind], self.lsf_xcoors[:,wavind], deg = poly_deg)
            self.vertical_trace_funcs.append(np.poly1d(opt))

        self.VERTICAL_TRACE = True


    # def load_LSF_model(self, modelname):

    #     loaded = np.load(modelname, allow_pickle = True)

    #     self.lsf_cutouts = loaded['cutouts']
    #     self.lsf_xcoors = loaded['xcoors']
    #     self.lsf_ycoors = loaded['ycoors']
    #     self.lsf_flag = loaded['flag']
    #     self.lsf_centroid_methods = loaded['method']

    #     self.flat_lsf_xcoors = self.lsf_xcoors.flatten()
    #     self.flat_lsf_ycoors = self.lsf_ycoors.flatten()
    #     self.flat_lsf_cutouts = np.reshape(self.lsf_cutouts, newshape=(self.NFIB*self.NWAV, np.shape(self.lsf_cutouts)[2], np.shape(self.lsf_cutouts)[3]))

    #     print("models loaded from", modelname)


    def make_clean_LSF_models(self, gridsize = 15, blob_find_width = 3, blob_thres = 1.2e-2, blob_maxwidth = 8,
                            # use_center_of_mass = False,
                            # use_25point_peak = False
                            centroid_thres = 1, 
                            save = False,
                            # filename = 'LSF_model'
                            ):
        

        os.makedirs(self.modelname+'/cutout_LSFs', exist_ok=True)
        # plt.tight_layout()

        self.lsf_failed_indices = []

        # self.model =
        self.lsf_cutouts = np.zeros((self.NFIB, self.NWAV, gridsize, gridsize))
        self.lsf_xcoors = np.zeros((self.NFIB, self.NWAV))
        self.lsf_ycoors = np.zeros((self.NFIB, self.NWAV))
        self.lsf_centroid_methods = np.zeros((self.NFIB, self.NWAV), dtype=object)
        self.lsf_centroid_methods[:] = ""
        self.lsf_flag = np.zeros((self.NFIB, self.NWAV)).astype(bool)

        for fibind in range(self.NFIB):
            fig, axs = plt.subplots(ncols=self.NWAV, figsize=(self.NWAV * 2, 2))
            fig.subplots_adjust(wspace=0, hspace=0, left=0, right=1, bottom=0)
            fig.suptitle('fibind %d' % fibind)

            for wavind in range(self.NWAV):
                
                try:
                    masked_im, xcoor, ycoor, centroid_method = self.make_cutout_LSF(fibind, wavind, plot=False, gridsize= gridsize,
                                                                blob_find_width = blob_find_width,
                                                                blob_thres = blob_thres,
                                                                blob_maxwidth = blob_maxwidth,
                                                                centroid_thres = centroid_thres
                                                                # use_center_of_mass= use_center_of_mass,
                                                                # use_25point_peak = use_25point_peak
                                                                )
                    self.lsf_xcoors[fibind, wavind] = xcoor
                    self.lsf_ycoors[fibind, wavind] = ycoor

                    self.lsf_centroid_methods[fibind, wavind] = centroid_method
                    self.lsf_cutouts[fibind, wavind] = masked_im

                    if not self.validate_cutout_LSF(masked_im):
                        print('fibind %d, wavind %d failed' % (fibind, wavind))
                        self.lsf_failed_indices.append((fibind, wavind))
                    else:
                        self.lsf_flag[fibind, wavind] = True

                    axs[wavind].imshow(masked_im, origin='lower')
                    axs[wavind].axhline(gridsize//2, color='white', alpha=0.5)
                    axs[wavind].axvline(gridsize//2, color='white', alpha=0.5)
                    axs[wavind].axis('off')
                except:
                    print('fibind %d, wavind %d failed' % (fibind, wavind))
                    axs[wavind].axis('off')
                    self.lsf_failed_indices.append((fibind, wavind))


            fig.savefig(self.modelname+'/cutout_LSFs/port%d.png' % (fibind))
            # axs[wavind].set_title('(%.2f, %.2f)' % (xcoor, ycoor))

        self.flat_lsf_xcoors = self.lsf_xcoors.flatten()
        self.flat_lsf_ycoors = self.lsf_ycoors.flatten()
        self.flat_lsf_cutouts = np.reshape(self.lsf_cutouts, newshape=(self.NFIB*self.NWAV, np.shape(self.lsf_cutouts)[2], np.shape(self.lsf_cutouts)[3]))

        # plt.show()

        if save:
            np.savez(self.modelname+'/LSF.npz',
                     cutouts = self.lsf_cutouts,
                     xcoors = self.lsf_xcoors,
                     ycoors = self.lsf_ycoors,
                     flag = self.lsf_flag,
                     method = self.lsf_centroid_methods
                     )
            print(self.modelname+'/LSF.npz saved')

    def validate_cutout_LSF(self, cutout, thres = 1):

        (cy, cx) = find_9point_peak_2d(cutout)
        size_cutout = len(cutout) // 2
        if (cx < size_cutout - thres) or (cx > size_cutout + thres) or (cy < size_cutout - thres) or (cy > size_cutout + thres):
            print("cutout image is not centered. %.2f, %.2f" % (cx - size_cutout, cy - size_cutout))
            return False
        else:
            return True        


    def make_cutout_LSF(self, fibind, wavind, gridsize = 21, blob_find_width = 3, blob_thres = 8e-3, blob_maxwidth = 8,
                            display_extended_width = 5, plot = True,
                            # use_center_of_mass = False,
                            # use_25point_peak = False,
                            # use_9point_peak = False,
                            shift_method = 'fft',
                            centroid_thres = 1):
        
        import cv2


        masked_im, x0, x1, y0, y1 = iter_find_blob(self.neon, self.ini_xs[fibind, wavind], self.ini_ys[fibind, wavind], 
                                                   ini_width=blob_find_width, thres=blob_thres,
                                                    maxwidth = blob_maxwidth,
                                                    plot = False,
                                                    return_masked = True
                                                    ) 


        (cy, cx), method_name = find_centroid(masked_im, verbose=False, thres = centroid_thres)
        
        on_interp = (self.trace_funcs[fibind](cx+x0))

        # compute the shift to make
        shift_x, shift_y = 0, np.round(on_interp) - on_interp

        # shift the image
        if shift_method == 'warpaffine':
            shifted_blob = shift_image_warpaffine(masked_im, shift_x, shift_y)
        elif shift_method == 'fft':
            shifted_blob = shift_image_fourier(masked_im, shift_x, shift_y, oversample_factor = 2, npad = 10)
        else:
            raise ValueError("shift_method should be either 'warpaffine' or 'fft'")
        
        # M = np.float32([[1,0,shift_x], [0,1,shift_y]])
        # shifted_blob = cv2.warpAffine(masked_im, M, (masked_im.shape[1], masked_im.shape[0]))
    
        # post on regular grid
        regular_grid = np.zeros((gridsize, gridsize))
        regular_grid[
                y0-np.round(on_interp).astype(int) + gridsize//2 : y1-np.round(on_interp).astype(int) + gridsize//2,
                x0-np.round(cx+x0).astype(int) + gridsize//2 : x1-np.round(cx+x0).astype(int) + gridsize//2 ] += shifted_blob
    
        if plot:

            plt.clf()
            # fig, axs = plt.subplots(ncols=2, figsize=(10,5))
            plt.imshow(self.neon[y0-display_extended_width:y1+display_extended_width,x0-display_extended_width:x1+display_extended_width], origin='lower',
                    extent = (x0-display_extended_width-0.5, x1+display_extended_width-0.5,y0-display_extended_width-0.5, y1+display_extended_width-0.5))
            plt.axvline(x0, color='white', alpha=0.5, linestyle=':')
            plt.axvline(x1, color='white', alpha=0.5, linestyle=':')
            plt.axhline(y0, color='white', alpha=0.5, linestyle=':')
            plt.axhline(y1, color='white', alpha=0.5, linestyle=':')
            self.plot_traces()
            
            plt.xlim([x0-display_extended_width, x1+display_extended_width])
            plt.ylim([y0-display_extended_width, y1+display_extended_width])

            plt.title('centroid (x,y) = (%.3f, %.3f)' % (cx+x0, cy+y0))
            plt.plot(cx + x0, cy + y0, 'o', color='red', label = 'centroid')

            plt.plot(cx + x0, on_interp, 'x', color='black', label = 'nearest point on the trace')

            plt.legend()

            print('coordinate (x,y) = (%.2f, %.2f)' % (cx+x0, on_interp))
            print('nearest coordinate (x,y) = (%d, %d)' % (np.round(cx+x0), np.round(on_interp)))
            
            print('required shift (x, y) = (%.3f, %.3f)' % (shift_x, shift_y) )

        # return regular_grid, masked_im, x0, x1, y0, y1, cx + x0, on_interp
    
        return regular_grid, cx+x0, on_interp, method_name
    
    def make_synthetic_LSFs(self, xmin, xmax, xstep = 50, plot = False):

        canvas = self.CANVAS.copy()

        failed_pos = []

        for fibind in range(self.NFIB):

            for x in np.arange(xmin, xmax, xstep):
                
                try:
                    lsf = self.get_LSF(fibind, x, return_canvas = True)
                    canvas += lsf

                except Exception as e:
                    print("fibind %d, x %d failed" % (fibind, x))
                    print(e)
                    failed_pos.append([x, self.trace_funcs[fibind](x)])
        
        if plot:

            plt.imshow(canvas, origin='lower')
            self.plot_traces()
            for (x, y) in failed_pos:
                plt.plot(x, y, 'x', color='red')

        return canvas

    def get_LSF(self, fibind, xcoor, plot = False, plotwidth = 15, return_canvas = False,
                use_griddata = False,
                use_interp1d = True,
                ycoor_correction = 0):
        
        ycoor = self.trace_funcs[fibind](xcoor) + ycoor_correction

        if use_griddata:
            lsf =  griddata((self.flat_lsf_xcoors, self.flat_lsf_ycoors), self.flat_lsf_cutouts, (xcoor, ycoor))

        if use_interp1d:
            lsf = interp1d(self.lsf_xcoors[fibind], self.lsf_cutouts[fibind], axis=0)(xcoor)

        if plot:
            applied_canvas = apply_patch(self.CANVAS, lsf, xcoor, ycoor)
            plt.imshow(applied_canvas)
            self.plot_traces()
            plt.xlim(xcoor - plotwidth, xcoor + plotwidth)
            plt.ylim(ycoor - plotwidth, ycoor + plotwidth)

        if return_canvas:
            return apply_patch(self.CANVAS, lsf, xcoor, ycoor)
        
        else:
            return lsf
    
    def construct_matrix(self, xmin, xmax, ycoor_correction_map):

        from scipy.sparse import lil_matrix
        from .utils import filter_nans

        A = lil_matrix(((xmax-xmin)* self.NFIB, self.NY * (xmax - xmin)))
        
        _ind = 0

        for fibind in tqdm(range(self.NFIB)):

            for x in np.arange(xmin, xmax):

                lsf = self.get_LSF(fibind, x, return_canvas = True,
                                   ycoor_correction= ycoor_correction_map[fibind, x])[:,xmin:xmax].flatten()
                
                if np.sum(~np.isfinite(lsf)) > 0:
                    print("nan occured at fibind %d, x %d" % (fibind, x))
                lsf = filter_nans(lsf)

                A[_ind, :] += lsf
        
                _ind += 1
        
        A = A.tocsr()
        self.A = A

        self.info = {'xmin':xmin, 'xmax':xmax}

        return A
    

    def iter_construct_matrix(self, xmin, xmax, n_iter = 3, ycoor_correction_map = None,
                              poly_deg_correction = 5,
                              var_const = 200, thresh = 1e-1,
                              trace_boxwidth = 4,
                              save_intermediate = False):
        '''
        Iteratively construct matrix, correcting for offsets in the y coordinates of the LSFs
        
        Parameters
        ----------
        xmin : int
            Minimum x coordinate for spectral extraction
        xmax : int
            Maximum x coordinate for spectral extraction
        n_iter : int
            Number of iterations to perform
        ycoor_correction_map : np.ndarray
            Initial y coordinate correction map
        poly_deg_correction : int
            Degree of polynomial to fit for correction
        var_const : float
            Variance constant
        thresh : float
            Threshold for damping
        trace_boxwidth : int
            Width of the box to trace the spectra
        '''

        if ycoor_correction_map is None:
            ycoor_correction_map = np.zeros((self.NFIB, self.NX))

        print("constructing initial matrix")
        A = self.construct_matrix(xmin, xmax, ycoor_correction_map)
        imvec = flatten_im(self.flat, xmin, xmax)
        spec, recon = extract_spec_optimal(A, imvec, var_const = var_const, thresh = thresh)

        all_As = [A]
        all_ycoor_correction_maps = [ycoor_correction_map]
        recons = [recon]

        if save_intermediate: 
            np.save('iter%d_A.npy' % i, A.toarray())
            np.save('iter%d_ycorr.npy' % i, ycoor_correction_map)
            
        for i in range(n_iter - 1):
            print("constructing matrix for iter %d" % (i+1))

            for fibind in range(self.NFIB):

                _cen = int(self.trace_vals[fibind][xmin - self.XMIN])
                _xarr = np.arange(_cen - trace_boxwidth, _cen + trace_boxwidth)
                _yarr_im = imvec.reshape((-1, xmax-xmin))[_xarr]
                _yarr_recon = recon.reshape((-1, xmax-xmin))[_xarr]

                shifts = []
                
                for _y, _y2 in zip(_yarr_im.T, _yarr_recon.T):

                    p1 = find_3point_peak(_xarr, _y)
                    p2 = find_3point_peak(_xarr, _y2)
                    shifts.append(p1-p2)
                
                opt = np.polyfit(np.arange(xmax-xmin), shifts, deg = poly_deg_correction)

                ycoor_correction_map[fibind, xmin:xmax] += np.poly1d(opt)(np.arange(xmax-xmin))

            A = self.construct_matrix(xmin, xmax, ycoor_correction_map)
            spec, recon = extract_spec_optimal(A, imvec, var_const = var_const, thresh = thresh)
            
            all_As.append(A)
            all_ycoor_correction_maps.append(ycoor_correction_map)
            recons.append(recon)

            if save_intermediate: 

                self.save_spectra_model('iter%d' % i)
                # np.save('iter%d_A.npy' % i, A.toarray())
                # np.save('iter%d_ycorr.npy' % i, ycoor_correction_map)


        fig, axs = plt.subplots(ncols=n_iter, figsize=(n_iter * 5, 5))
        for i in range(n_iter):
            axs[i].imshow((imvec - recons[i]).reshape((-1, xmax-xmin)), origin='lower')
            axs[i].set_title('iter %d residual' % i)
        plt.show()

        return all_As, all_ycoor_correction_maps, recons, imvec.reshape((-1, (xmax-xmin)))


    def build_wavelength_solutions(self, valid_inds, xmin, xmax, poly_deg = 3, save = False, filename = 'wavmap'):

        '''
        Build wavelength solutions for each fiber using the detected neon lines

        Parameters
        ----------
        valid_inds : np.ndarray
            Indices of the valid neon lines
        xmin : int
            Minimum x coordinate for wavelength solution
        xmax : int
            Maximum x coordinate for wavelength solution
        poly_deg : int
            Degree of polynomial to fit wavelength solutions
        save : bool
            Save the wavelength solutions
        filename : str
            Filename to save the wavelength solutions
        '''

        self.wave_sol_funcs = []
        self.wav_map = []

        warr = np.arange(xmin, xmax)

        for fibind in range(self.NFIB):
            opt = np.polyfit(self.lsf_xcoors[fibind,valid_inds], np.array(self.WAVS)[valid_inds], deg = poly_deg)
            self.wave_sol_funcs.append(opt)
            self.wav_map.append(np.polyval(opt, warr))

        self.wav_map = np.array(self.wav_map)
        self.wave_sol_funcs = np.array(self.wave_sol_funcs)

        if save:
            np.save(filename+'.npy', self.wav_map)
            print(filename+'.npy saved')

    def save_spectra_model(self, filename):

        # np.savez(filename+'.npz',
        #          matrix = self.A,
        #          wav_map = self.wav_map,
        #          info = self.info
        #          )
        # print(filename+'.npz saved')

        # I need to do this because lab testing code runs in a different environment
        # which doesn't allow loading the file above
        

        try:
            from scipy.sparse import save_npz
            save_npz(self.modelname+'/'+filename+'_matrix.npz', self.A)
            print("matrix saved to %s" % self.modelname+'/'+filename+'_matrix.npz')
        except:
            print("couldn't save the matrix.")
        
        try:
            np.save(self.modelname+'/'+filename+'_wavmap.npy', self.wav_map)
            print("wavmap saved to %s" % self.modelname+'/'+filename+'_wavmap.npy')
        except:
            print("couldn't save the wavmap.")
        
        try:
            np.save(self.modelname+'/'+filename+'_info.npy', self.info)
            print("info saved to %s" % self.modelname+'/'+filename+'_info.npy')
        except:
            print("couldn't save the info.")


    def load_spectra_model(self, filename):


        try:
            from scipy.sparse import load_npz
            self.A = load_npz(self.modelname+'/'+filename+'_matrix.npz')
        except:
            print("couldn't load the matrix.")

        try:
            self.wav_map = np.load(self.modelname+'/'+filename+'_wavmap.npy')
        except:
            print("couldn't load the wavmap.")
        
        try:
            self.info = np.load(self.modelname+'/'+filename+'_info.npy', allow_pickle = True)
        except:
            print("couldn't load the info.")

        print("model loaded from", self.modelname+'/'+filename)


if __name__ == '__main__':

    plt.ion()

    sm = SpectrumModel(neonfile = '../neon_data_240914.npy', flatfile = '../flat_data_240917.npy',
                       modelfile = 'LSF_model2.npz',
                       tracefile = 'trace.npy')
    
    # do steps below if tracefile doesn't exist

    # sm.find_peaks()
    # sm.trace_spectra(3)

    # do steps below if modelfile doesn't exist
    # sm.make_clean_LSF_models(gridsize= 15, blob_thres = 1.2e-2)

    # to check if making synthetic LSFs works,
    # sm.make_synthetic_LSFs(sm.XMIN, sm.XMAX, plot = True, xstep = 25)

